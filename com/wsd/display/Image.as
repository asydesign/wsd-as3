package com.wsd.display{	import com.adobe.images.JPGEncoder;		import com.wsd.Base;	import com.wsd.View;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.PixelSnapping;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.net.URLRequest;		public class Image extends View	{		private var target:*;		public var loader:Loader = new Loader();		private var url:String;		private var callbackLoaded:Function;		private var options:Object				public function Image(url:String, target:*, callbackLoaded:Function = null, options:Object = null):*		{			Base.log('Image::constructor url = ' + url + ' | target = ' + target);						this.url = url;			this.target = target;			this.callbackLoaded = callbackLoaded			this.options = options == null ? new Object : options						var request:URLRequest = new URLRequest(url);			loader.name = 'img';			loader.load(request);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded, false, 0, true);		}				private function loaded( e:Event ):void		{			Base.log('Image::loaded url = ' + url);						Base.log('Image::loaded options.width = ' + typeof(options.width))						target.addChild(loader);			trace(loader)						if (typeof(options.width) == 'number') {				Base.log('Image::loaded width = ' + options.width)								loader.height = (options.width * loader.height) / loader.width				loader.width = options.width				Base.log('Image::loaded width = ' + loader.width + ' height = ' + loader.height)			}						if (callbackLoaded != null) callbackLoaded()		}				public static function toByteArray(object:*, prop:Object = null):*		{			if (prop == null) 	prop = {};			if (prop.width == null ) prop.width 		= object.width;			if (prop.height == null ) prop.height 		= object.height;			if (prop.quality == null ) prop.quality 	= 100;						var data:BitmapData = new BitmapData( prop.width, prop.height );			data.draw( object );						var jpgEncoder:* = new JPGEncoder(prop.quality);            return jpgEncoder.encode(data);		}				public static function crop( _x:Number, _y:Number, _width:Number, _height:Number, displayObject:DisplayObject ):Bitmap		{			/*			var cropArea:Rectangle = new Rectangle( 0, 0, _width, _height );			var croppedBitmap:Bitmap = new Bitmap( new BitmapData( _width, _height ), PixelSnapping.ALWAYS, true );			croppedBitmap.bitmapData.draw( displayObject, new Matrix(1, 0, 0, 1, -_x, -_y) , null, null, cropArea, true );			return croppedBitmap;			*/			return new Bitmap()		}				public static function cropMask(mcHolder, mcMask):Bitmap {			//Matrix to holder the area to be cropped			var maskRect = mcMask.getBounds(mcHolder);			//Matrix of image to be cropped			var imgMatrix= mcHolder.transform.matrix;			//Cropped image			return Image.cropMatrix(maskRect, imgMatrix, mcMask.width, mcMask.height,mcHolder );		}		public static function cropMatrix( rect, matrix, _width:Number, _height:Number, displayObject:DisplayObject ):Bitmap {		 	//Create cropped image			var croppedBitmap:Bitmap = new Bitmap( new BitmapData( _width, _height ), PixelSnapping.ALWAYS, true );			croppedBitmap.bitmapData.draw(displayObject, matrix , null, null, rect, true );			return croppedBitmap;		}				public static function duplicate( bitmap:* ):Bitmap		{			return new Bitmap( bitmap.bitmapData );		}	}}